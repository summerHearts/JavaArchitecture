##MySQL事务
- mysql阻塞原因思考

    ![](https://www.icheesedu.com/images/qiniu/Xnip2018-06-176_11-11-36.png)
    
     - 主键
     -  隔离级别
     - 索引，是否是唯一索引
     - mysql的执行计划
   
- 什么是事务
     - MySQL 事务主要用于处理操作量大，复杂度高的数据。比如说，在人员管理系统中，你删除一个人员，你即需要删除人员的基本资料，也要删除和该人员相关的信息，如信箱，文章等等，这样，这些数据库操作语句就构成一个事务！
        - 在 MySQL 中只有使用了**Innodb** 数据库引擎的数据库或表才支持事务。
        - **事务处理可以用来维护数据库的完整性**，保证成批的 SQL 语句要么全部执行，要么全部不执行。
        - 事务用来管理**insert**,**update**,**delete** 语句

- **事务的属性**
   事务是必须满足4个条件（ACID）

 - 原子性（Atomicity，或称不可分割性）
     - 一个事务（transaction）中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。
 - 一致性（Consistency）
     - 在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设规则，这包含资料的精确度、串联性以及后续数据库可以自发性地完成预定的工作。
 - 隔离性（Isolation，又称独立性）
     - 数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。**事务隔离**分为不同**级别**，包括**读未提交（Read uncommitted）**、**读提交（read committed）**、**可重复读（repeatable read）**和**串行化（Serializable）**。
  - 持久性（Durability)
      - 持久性：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。
- 事务编程
    ![](https://www.icheesedu.com/images/qiniu/Xnip2018-06-176_11-09-55.png)
    
- 并发会存在的问题
   -  **dirty read 脏读**
     - **脏读**：脏读就是指当一个事务正在访问数据，并且对数据进行了修改，而这种修改还没有提交到数据库中，这时，另外一个事务也访问这个数据，然后使用了这个数据。
     - **例如**：张三的工资为5000,事务A中把他的工资改为8000,但事务A尚未提交。与此同时，事务B正在读取张三的工资，读取到张三的工资为8000。随后，事务A发生异常，而回滚了事务。张三的工资又回滚为5000。最后，事务B读取到的张三工资为8000的数据即为脏数据，事务B做了一次脏读。
   -  **unrepeatable read 不可重复读**
     - **不可重复读**：是指在一个事务内，多次读同一数据。在这个事务还没有结束时，另外一个事务也访问该同一数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改，那么第一个事务两次读到的的数据可能是不一样的。这样就发生了在一个事务内两次读到的数据是不一样的，因此称为是不可重复读。
     -  **例如**：在事务A中，读取到张三的工资为5000，操作没有完成，事务还没提交。与此同时，事务B把张三的工资改为8000，并提交了事务。随后，在事务A中，再次读取张三的工资，此时工资变为8000。在一个事务中前后两次读取的结果并不致，导致了不可重复读。
   -  **phantom read 幻读**
     - **幻读**：是指当事务不是独立执行时发生的一种现象，例如第一个事务对一个表中的数据进行了修改，这种修改涉及到表中的全部数据行。同时，第二个事务也修改这个表中的数据，这种修改是向表中插入一行新数据。那么，以后就会发生操作第一个事务的用户发现表中还有没有修改的数据行，就好象发生了幻觉一样。
     - **例如**：目前工资为5000的员工有10人，事务A读取所有工资为5000的人数为10人。此时，事务B插入一条工资也为5000的记录。这是，事务A再次读取工资为5000的员工，记录为11人。此时产生了幻读。
     
    -  **提醒**：
       - 不可重复读的重点是修改，同样的条件，你读取过的数据，再次读取出来发现值不一样了
       - 幻读的重点在于新增或者删除，同样的条件，第 1 次和第 2 次读出来的记录数不一样

- 事务的隔离级别
   ![](https://www.icheesedu.com/images/qiniu/Xnip2018-06-176_12-46-49.png)
   ![](https://www.icheesedu.com/images/qiniu/Xnip2018-06-176_12-58-16.png)
   
   - **Read uncommitted**
       - 读未提交，顾名思义，就是一个事务可以读取另一个未提交事务的数据。

       - 事例：老板要给程序员发工资，程序员的工资是3.6万/月。但是发工资时老板不小心按错了数字，按成3.9万/月，该钱已经打到程序员的户口，但是事务还没有提交，就在这时，程序员去查看自己这个月的工资，发现比往常多了3千元，以为涨工资了非常高兴。但是老板及时发现了不对，马上回滚差点就提交了的事务，将数字改成3.6万再提交。

       - 分析：实际程序员这个月的工资还是3.6万，但是程序员看到的是3.9万。他看到的是老板还没提交事务时的数据。这就是脏读。

 那怎么解决脏读呢？Read committed！读提交，能解决**脏读**问题。
 
   -  **Read committed**

       - 读提交，顾名思义，就是一个事务要等另一个事务提交后才能读取数据。

       - 事例：程序员拿着信用卡去享受生活（卡里当然是只有3.6万），当他埋单时（程序员事务开启），收费系统事先检测到他的卡里有3.6万，就在这个时候！！程序员的妻子要把钱全部转出充当家用，并提交。当收费系统准备扣款时，再检测卡里的金额，发现已经没钱了（**第二次检测金额当然要等待妻子转出金额事务提交完**）。程序员就会很郁闷，明明卡里是有钱的…

       - 分析：这就是读提交，若有事务对数据进行更新（UPDATE）操作时，读操作事务要等待这个更新操作事务提交后才能读取数据，可以解决脏读问题。但在这个事例中，出现了**一个事务范围内两个相同的查询却返回了不同数据**，这就是**不可重复读**。
       

  那怎么解决可能的不可重复读问题？Repeatable read ！
 
   -   **Repeatable read** Mysql的默认隔离级别是Repeatable read。

       - 重复读，就是在开始读取数据（事务开启）时，不再允许修改操作

       - 事例：程序员拿着信用卡去享受生活（卡里当然是只有3.6万），当他埋单时（事务开启，不允许其他事务的UPDATE修改操作），收费系统事先检测到他的卡里有3.6万。这个时候他的妻子不能转出金额了。接下来收费系统就可以扣款了。

       - 分析：重复读可以解决不可重复读问题。写到这里，应该明白的一点就是，不可重复读对应的是修改，即UPDATE操作。但是可能还会有幻读问题。因为幻读问题对应的是插入INSERT操作，而不是UPDATE操作。

   -   **什么时候会出现幻读？**

       - 事例：程序员某一天去消费，花了2千元，然后他的妻子去查看他今天的消费记录（全表扫描FTS，妻子事务开启），看到确实是花了2千元，就在这个时候，程序员花了1万买了一部电脑，即新增INSERT了一条消费记录，并提交。当妻子打印程序员的消费记录清单时（妻子事务提交），发现花了1.2万元，似乎出现了幻觉，这就是幻读。

   那怎么解决幻读问题？Serializable！
   
   -   **Serializable 序列化**

       - Serializable 是最高的事务隔离级别，在该级别下，事务串行化顺序执行，可以避免脏读、不可重复读与幻读。但是这种事务隔离级别效率低下，比较耗数据库性能，一般不使用。

- **事务编程的不好习惯**
    ![](https://www.icheesedu.com/images/qiniu/Xnip2018-06-176_12-59-35.png)
    
- **锁的概念**
   - 锁用于在多个事务访问同一个对象时根据这些操作访问同一个对象的先后次序给事务排序。
   - 不同数据库的锁的实现
      - InnoDB 行级锁
      - Oracle 行级锁
      - MyISAM 表锁
    - Lock与Latch的区别
      ![](https://images2015.cnblogs.com/blog/754297/201601/754297-20160131225332443-857830570.jpg)
      
      - 在InnoDB存储引擎中的latch，可以通过命令SHOW ENGINE INNODB MUTEX 来进行查看
       
       ![](https://www.icheesedu.com/images/qiniu/Xnip2018-06-176_13-54-51.png)

       ![](https://images2015.cnblogs.com/blog/754297/201601/754297-20160131230428146-1539680077.jpg)
       
-  **InnoDB锁分析**

  ![](https://www.icheesedu.com/images/qiniu/Xnip2018-06-176_14-00-59.png)

-  **锁的兼容性**
   
   ![](https://www.icheesedu.com/images/qiniu/Xnip2018-06-176_14-11-26.png)
   
    - 如果一个事务请求的锁模式与当前的锁兼容，InnoDB就请求的锁授予该事务；反之，如果两者两者不兼容，该事务就要等待锁释放。
    - 意向锁是InnoDB自动加的，不需用户干预。对于UPDATE、DELETE和INSERT语句，InnoDB会自动给涉及及数据集加排他锁（Ｘ）；对于普通SELECT语句，InnoDB会自动给涉及数据集加排他锁（Ｘ）；对于普通SELECT语句，InnoDB不会任何锁；事务可以通过以下语句显示给记录集加共享锁或排锁。
    - 共享锁（Ｓ）：SELECT * FROM table_name WHERE ... LOCK IN SHARE MODE
    - 排他锁（X）：SELECT * FROM table_name WHERE ... FOR UPDATE
    - 用SELECT .. IN SHARE MODE获得共享锁，主要用在需要数据依存关系时确认某行记录是否存在，并确保没有人对这个记录进行UPDATE或者DELETE操作。但是如果当前事务也需要对该记录进行更新操作，则很有可能造成死锁，对于锁定行记录后需要进行更新操作的应用，应该使用SELECT ... FOR UPDATE方式获取排他锁。

- **InnoDB行锁实现方式**

   - InnoDB行锁是通过索引上的索引项来实现的，这一点ＭySQL与Oracle不同，后者是通过在数据中对相应数据行加锁来实现的。InnoDB这种行锁实现特点意味者：只有通过索引条件检索数据，InnoDB才会使用行级锁，否则，InnoDB将使用表锁！
   - 在实际应用中，要特别注意InnoDB行锁的这一特性，不然的话，可能导致大量的锁冲突，从而影响并发性能。
    
   
-  **InnoDB row lock (行锁)** **锁的范围**
    - InnoDB行锁是通过给索引上的索引项加锁来实现的，只有通过索引条件检索数据，InnoDB才使用行级锁，否则，InnoDB将使用表锁
    - 在实际应用中，要特别注意InnoDB行锁的这一特性，不然的话，可能导致大量的锁冲突，从而影响并发性能。下面通过一些实际例子来加以说明。
      -  1、在不通过索引条件查询的时候，InnoDB确实使用的是表锁，而不是行锁。
      -  2、由于MySQL的行锁是针对索引加的锁，不是针对记录加的锁，所以虽然是访问不同行的记录，但是如果是使用相同的索引键，是会出现锁冲突的。
      -  3、当表有多个索引的时候，不同的事务可以使用不同的索引锁定不同的行，另外，不论是使用主键索引、唯一索引或普通索引，InnoDB都会使用行锁来对数据加锁。
      - 4、即便在条件中使用了索引字段，但是否使用索引来检索数据是由MySQL通过判断不同执行计划的代价来决定的，如果MySQL认为全表扫描效率更高，比如对一些很小的表，它就不会使用索引，这种情况下InnoDB将使用表锁，而不是行锁。因此，在分析锁冲突时，别忘了检查SQL的执行计划，以确认是否真正使用了索引。

  ![](https://www.icheesedu.com/images/qiniu/Xnip2018-06-176_14-15-54.png)
  
  - 只有重复读才有 GAP Lock 间隔锁  。

  ![](https://www.icheesedu.com/images/qiniu/Xnip2018-06-176_14-30-23.png)
  
  - **间隙锁（Next-Key锁）**

       - 当我们用范围条件而不是相等条件检索数据，并请求共享或排他锁时，InnoDB会给符合条件的已有数据的索引项加锁；对于键值在条件范围内但并不存在的记录，叫做“间隙(GAP)”，InnoDB也会对这个“间隙”加锁，这种锁机制不是所谓的间隙锁（Next-Key锁）。
       - 举例来说，假如emp表中只有101条记录，其empid的值分别是1,2,...,100,101，下面的SQL：
          SELECT * FROM emp WHERE empid > 100 FOR UPDATE
       - 是一个范围条件的检索，InnoDB不仅会对符合条件的empid值为101的记录加锁，也会对empid大于101（这些记录并不存在）的“间隙”加锁。
       - InnoDB使用间隙锁的目的，一方面是为了防止幻读，以满足相关隔离级别的要求，对于上面的例子，要是不使用间隙锁，如果其他事务插入了empid大于100的任何记录，那么本事务如果再次执行上述语句，就会发生幻读；另一方面，是为了满足其恢复和复制的需要。有关其恢复和复制对机制的影响，以及不同隔离级别下InnoDB使用间隙锁的情况。
      - 很显然，在使用范围条件检索并锁定记录时，InnoDB这种加锁机制会阻塞符合条件范围内键值的并发插入，这往往会造成严重的锁等待。因此，在实际开发中，尤其是并发插入比较多的应用，我们要尽量优化业务逻辑，尽量使用相等条件来访问更新数据，避免使用范围条件。
  
- **RR隔离级别gap lock和Next-Key Locks测试**：   
  - 1.**非唯一索引，范围搜索时加锁  最终都要追踪到主键上的**
  ![](https://www.icheesedu.com/images/qiniu/Xnip2018-06-176_16-34-39.png)
  - 2.**非唯一索引，唯一匹配搜索时候加锁  最终都要追踪到主键上的**
  ![](https://www.icheesedu.com/images/qiniu/Xnip2018-06-176_17-11-01.png)
  - 3.**唯一索引，范围搜索时候加锁**
  ![](https://www.icheesedu.com/images/qiniu/Xnip2018-06-176_17-43-49.png)
  
- **一些查看数据库中事务和锁情况的常用语句**
  
  ![](https://www.icheesedu.com/images/qiniu/Xnip2018-06-176_17-47-30.png)
  
- 死锁
   - 在InnoDB中，除单个SQL组成的事务外，锁是逐步获得的，当两个事务都需要获得对方持有的排他锁才能继续完成事务，这种循环锁等待就是典型的死锁。
   - 在InnoDB的事务管理和锁定机制中，有专门检测死锁的机制，会在系统中产生死锁之后的很短时间内就检测到该死锁的存在。
   - 当InnoDB检测到系统中产生了死锁之后，InnoDB会通过相应的判断来选这产生死锁的两个事务中较小的事务来回滚，而让另外一个较大的事务成功完成。
   - 那InnoDB是以什么来为标准判定事务的大小的呢？MySQL官方手册中也提到了这个问题，实际上在InnoDB发现死锁之后，会计算出两个事务各自插入、更新或者删除的数据量来判定两个事务的大小。
   - 也就是说哪个事务所改变的记录条数越多，在死锁中就越不会被回滚掉。
   - 但是有一点需要注意的就是，当产生死锁的场景中涉及到不止InnoDB存储引擎的时候，InnoDB是没办法检测到该死锁的，这时候就只能通过锁定超时限制参数InnoDB_lock_wait_timeout来解决。
   - 需要说明的是，这个参数并不是只用来解决死锁问题，在并发访问比较高的情况下，如果大量事务因无法立即获得所需的锁而挂起，会占用大量计算机资源，造成严重性能问题，甚至拖跨数据库。
   - 我们通过设置合适的锁等待超时阈值，可以避免这种情况发生。
   - 通常来说，死锁都是应用设计的问题，通过调整业务流程、数据库对象设计、事务大小，以及访问数据库的SQL语句，绝大部分死锁都可以避免。下面就通过实例来介绍几种避免死锁的常用方法：

       -  1、在应用中，如果不同的程序会并发存取多个表，应尽量约定以相同的顺序来访问表，这样可以大大降低产生死锁的机会。
       - 2、在程序以批量方式处理数据的时候，如果事先对数据排序，保证每个线程按固定的顺序来处理记录，也可以大大降低出现死锁的可能。
      - 3、在事务中，如果要更新记录，应该直接申请足够级别的锁，即排他锁，而不应先申请共享锁，更新时再申请排他锁，因为当用户申请排他锁时，其他事务可能又已经获得了相同记录的共享锁，
　　 从而造成锁冲突，甚至死锁。
      - 4、在REPEATABLE-READ隔离级别下，如果两个线程同时对相同条件记录用SELECT...FOR UPDATE加排他锁，在没有符合该条件记录情况下，两个线程都会加锁成功。程序发现记录尚不存在，
　　 就试图插入一条新记录，如果两个线程都这么做，就会出现死锁。这种情况下，将隔离级别改成READ COMMITTED，就可避免问题。
     - 5、当隔离级别为READ COMMITTED时，如果两个线程都先执行SELECT...FOR UPDATE，判断是否存在符合条件的记录，如果没有，就插入记录。此时，只有一个线程能插入成功，另一个线程会出现锁等待，当第1个线程提交后，第2个线程会因主键重出错，但虽然这个线程出错了，却会获得一个排他锁。这时如果有第3个线程又来申请排他锁，也会出现死锁。
     
     - 6、对于这种情况，可以直接做插入操作，然后再捕获主键重异常，或者在遇到主键重错误时，总是执行ROLLBACK释放获得的排他锁。


